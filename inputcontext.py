# 生成context，并接触replaceName中的函数代替用户自定义的 变量名和函数名等
import json
from collections import deque
from io import StringIO


def fix_txt(base):
    """
    处理初始的文本数据
    """
    file_data = ''
    with open(base, 'r', encoding='utf-8') as f:
        for line in f:
            if 'stringLiteral' in line:
                file_data += line
                for line2 in f:
                    if '"}' in line2:
                        li = line2.split('"}')
                        line2 = '"value":"string"}'+li[-1]
                        file_data += line2
                        break
                    else:
                        continue
            else:
                if "'" in line:
                    line = line.replace("'", '"')
                if 'None,' in line:
                    line = line.replace('None,', '"None",')
                if 'True,' in line:
                    line = line.replace('True,', '"True",')
                if 'True}' in line:
                    line = line.replace('True}', '"True"}')
                if 'False,' in line:
                    line = line.replace('False,', '"False",')
                if 'False}' in line:
                    line = line.replace('False}', '"False"}')
                if 'hex"' in line:
                    line = '"value": "hex",'
                if 'None],' in line:
                    line = '{"value": "None"}'
                file_data += line
    # print(file_data)
    with open(base, "w", encoding='utf-8') as f:
        f.write(file_data)


fix_txt('test.txt')
with open('test.txt', 'r', encoding='utf-8') as f:
    dic = json.load(f)


class Tree:
    def __init__(self, json_obj, name='contract'):
        self.name = name
        self.children = []
        self.json_obj = json_obj

    def append_child(self, tree):
        self.children.append(tree)


def json_to_tree(json_obj):
    """
    利用广度优先遍历将 json 转换为自定义的 tree 类型
    """
    tree = Tree(json_obj)
    temp_node_arr = deque([])
    for k, v in json_obj.items():
        temp_tree_node = Tree(v, k)
        temp_node_arr.appendleft(temp_tree_node)
        tree.append_child(temp_tree_node)

    while len(temp_node_arr) != 0:
        n = len(temp_node_arr)
        for i in range(n):
            child = temp_node_arr.pop()
            if isinstance(child.json_obj, list) and len(child.json_obj) != 0:
                # 有多个子节点
                for index, obj in enumerate(child.json_obj):
                    muti_child = Tree(obj, 'child'+str(index))
                    child.append_child(muti_child)
                    temp_node_arr.appendleft(muti_child)
            elif isinstance(child.json_obj, dict):
                for k, v in child.json_obj.items():
                    if isinstance(v, list) and len(v) > 0:
                        # 加入到一个列表中
                        child_temp = Tree(v, k)
                        child.append_child(child_temp)
                        temp_node_arr.appendleft(child_temp)
                    elif isinstance(v, dict):
                        # 加入到一个列表中
                        for key, value in v.items():
                            child_temp = Tree(value, key)
                            child.append_child(child_temp)
                            temp_node_arr.appendleft(child_temp)
                    else:
                        child_temp = Tree(None, k)
                        child_temp02 = Tree(None, v)
                        child_temp.append_child(child_temp02)
                        child.append_child(child_temp)
                        # print(k, v)
            else:
                continue
    return tree


tree = json_to_tree(dic)


def dfsSerialize(cur_node, res):
    res.write(str(cur_node.name))
    if cur_node.children and len(cur_node.children)>0:
        res.write(' ( ')
        for node in cur_node.children:
            dfsSerialize(node, res)
            # res.write(' ')
        res.write(' ) ')


def tree2str(root) -> str:
    """
    层序遍历
    """
    if not root:
        return ''
    res = StringIO()
    dfsSerialize(root, res)
    return res.getvalue()


string = tree2str(tree)
print(string)